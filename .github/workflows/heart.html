<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>heart</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background-color: #f5f5f5;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }
        .text-item {
            position: absolute;
            color: white;
            font-family: "SimHei", "Microsoft YaHei", sans-serif;
            font-weight: bold;
            padding: clamp(4px, 2vw, 8px) clamp(8px, 3vw, 12px);
            border-radius: clamp(12px, 5vw, 18px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            user-select: none;
            white-space: nowrap;
            font-size: clamp(12px, 3vw, 20px);
            transform: translate(0, 0);
        }
    </style>
</head>
<body>
    <script>
        const texts = [
            "你的笑真好看", "多喝热水", "梦会实现", "温柔又坚定",
            "少些烦恼", "雨后会晴", "希望你永远开心", "未来可期", "你一直很棒",
            "多笑一笑", "你是独一无二的", "要一直加油","开心每一天",
            "快快乐乐", "风会告诉你方向", "照顾好自己", "事事顺心",
            "好运连连", "平安喜乐", "闪闪发光", "人间值得",
            "美好常在","所求皆所愿","前途坦荡","愿你被世界温柔对待",
            "美好慢慢相遇","你的眼里有星光","每天都有小欢喜",
            "日子温暖又闪光","累了就歇一歇","你值得被爱","顺利常伴左右",
            "笑容永远灿烂","温暖一直都在","万事皆有好结果","烦恼恼都走开",
            "眼里总有热爱","平安常伴左右","快乐不打烊","你本就很优秀",
            "未来满是阳光","美好如期而至","你的可爱爱会发光","疲惫会被治愈",
            "笑容自带阳光","心中热爱常在","笑口常开","你超棒的","天天开心",
            "一切顺利","别担心","有我呢","会好的","加油油啊","哇酷哇酷","慢慢来",
            "别着急","今天也在发光","大胆胆向前走","你笑超治愈","温暖藏心底",
        ];

        const styles = [
            { bg: "#FF6B8B", border: "#E05A7A" },
            { bg: "#6B9FFF", border: "#5A8EE0" },
            { bg: "#6BFFB8", border: "#5AE0A7" },
            { bg: "#FFD66B", border: "#E0C05A" },
            { bg: "#C66BFF", border: "#B05AE0" }
        ];

        let windowWidth = window.innerWidth;
        let windowHeight = window.innerHeight;
        let isMobile, isTablet, isDesktop;

        // 设备类型判断与尺寸更新
        function updateDeviceInfo() {
            windowWidth = window.innerWidth;
            windowHeight = window.innerHeight;
            isMobile = windowWidth < 768;
            isTablet = windowWidth >= 768 && windowWidth < 1024;
            isDesktop = windowWidth >= 1024;
        }

        let textElements = [];
        let animationId = null;
        let batchSize, interBatchDelay; // 动态设置批次参数
        const intraBatchDelay = 50;
        let lastTime = 0;

        function createTextElements() {
            textElements.forEach(el => el.remove());
            textElements = [];
            
            updateDeviceInfo();
            // 动态设备类型动态调整批次参数
            batchSize = isMobile ? 3 : 5;
            interBatchDelay = isMobile ? 800 : 1000;
            
            const { width, height } = { width: windowWidth, height: windowHeight };
            
            // 自适应聚拢范围
            let scaleFactor;
            if (isMobile) {
                scaleFactor = 0.4; // 手机：更大占比
            } else if (isTablet) {
                scaleFactor = 0.35; // 平板：中等占比
            } else {
                scaleFactor = 0.3; // 桌面：标准占比
            }
            
            const rectRatio = isMobile ? 1.5 : 1.8; // 手机更接近正方形比例
            const baseSize = Math.min(width, height) * scaleFactor;
            const rectWidth = baseSize * rectRatio;
            const rectHeight = baseSize;
            const centerX = width / 2;
            const centerY = height / 2;
            
            // 初始位置偏移量（手机设备调整）
            const offset = isMobile ? 
                Math.max(150, width * 0.2) : 
                Math.max(100, width * 0.15);
            
            // 长方形区域分布算法（修正笔误笔误：修正函数名）
            const getRectPosition = () => {
                const x = centerX - rectWidth/2 + Math.random() * rectWidth;
                const y = centerY - rectHeight/2 + Math.random() * rectHeight;
                
                // 边缘概率根据设备调整
                const edgeBias = isMobile ? 0.25 : 0.2;
                if (Math.random() < edgeBias) {
                    const edge = Math.floor(Math.random() * 4);
                    switch(edge) {
                        case 0: return { x, y: centerY - rectHeight/2 + Math.random() * (isMobile ? 15 : 20) };
                        case 1: return { x: centerX + rectWidth/2 - Math.random() * (isMobile ? 15 : 20), y };
                        case 2: return { x, y: centerY + rectHeight/2 - Math.random() * (isMobile ? 15 : 20) };
                        case 3: return { x: centerX - rectWidth/2 + Math.random() * (isMobile ? 15 : 20), y };
                    }
                }
                return { x, y };
            };

            texts.forEach((text, index) => {
                const div = document.createElement('div');
                div.className = 'text-item';
                div.textContent = text;
                
                const style = styles[Math.floor(Math.random() * styles.length)];
                div.style.backgroundColor = style.bg;
                div.style.border = `2px solid ${style.border}`;
                
                // 随机初始边缘位置
                const edge = Math.floor(Math.random() * 4);
                let startX, startY;
                switch(edge) {
                    case 0:
                        startX = 20 + Math.random() * (width - 40);
                        startY = -offset - Math.random() * offset;
                        break;
                    case 1:
                        startX = 20 + Math.random() * (width - 40);
                        startY = height + offset + Math.random() * offset;
                        break;
                    case 2:
                        startX = -offset - Math.random() * offset;
                        startY = 20 + Math.random() * (height - 40);
                        break;
                    case 3:
                        startX = width + offset + Math.random() * offset;
                        startY = 20 + Math.random() * (height - 40);
                        break;
                }
                
                // 获取目标位置（修正笔误）
                const targetPos = getRectPosition();
                const targetX = targetPos.x;
                const targetY = targetPos.y;
                
                div.style.transform = `translate(${startX}px, ${startY}px)`;
                document.body.appendChild(div);
                
                // 计算启动时间：按批次延迟
                const batchIndex = Math.floor(index / batchSize);
                const withinBatchIndex = index % batchSize;
                const startTime = performance.now() + 
                    (batchIndex * interBatchDelay) + 
                    (withinBatchIndex * intraBatchDelay);
                
                textElements.push({
                    el: div,
                    startX,
                    startY,
                    targetX,
                    targetY,
                    // 手机上稍快一点，补偿屏幕小的视觉差异
                    speed: isMobile ? 0.12 + Math.random() * 0.1 : 0.1 + Math.random() * 0.1,
                    ease: 0.03 + Math.random() * 0.02,
                    currentX: startX,
                    currentY: startY,
                    startTime,
                    hasStarted: false,
                    hasArrived: false
                });
            });
        }

        function animate(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const deltaTime = timestamp - lastTime;
            if (deltaTime < 16.67) {
                animationId = requestAnimationFrame(animate);
                return;
            }
            lastTime = timestamp;

            const now = performance.now();
            let allArrived = true;

            for (let i = 0; i < textElements.length; i++) {
                const item = textElements[i];

                if (!item.hasStarted && now < item.startTime) {
                    allArrived = false;
                    continue;
                }

                if (!item.hasStarted) {
                    item.hasStarted = true;
                }

                if (item.hasArrived) continue;

                const dx = item.targetX - item.currentX;
                const dy = item.targetY - item.currentY;
                const distance = Math.hypot(dx, dy);

                if (distance > 1.2) {
                    allArrived = false;
                    item.currentX += dx * item.ease * item.speed;
                    item.currentY += dy * item.ease * item.speed;
                    item.el.style.transform = `translate(${item.currentX}px, ${item.currentY}px)`;
                } else {
                    item.hasArrived = true;
                    item.el.style.transform = `translate(${item.targetX}px, ${item.targetY}px)`;
                }
            }

            if (!allArrived) {
                animationId = requestAnimationFrame(animate);
            } else {
                startBreathing();
            }
        }

        function startBreathing() {
            for (let i = 0; i < textElements.length; i++) {
                const item = textElements[i];
                const scale = 1 + (Math.random() - 0.5) * (isMobile ? 0.025 : 0.02);
                item.el.style.transform = `translate(${item.targetX}px, ${item.targetY}px) scale(${scale})`;
            }
            setTimeout(startBreathing, 300);
        }

        function init() {
            if (animationId) cancelAnimationFrame(animationId);
            lastTime = 0;
            createTextElements();
            animationId = requestAnimationFrame(animate);
        }

        // 窗口 resize 处理
        let resizeTimer = null;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                init();
            }, 150);
        });

        // 初始化
        updateDeviceInfo();
        init();
    </script>
</body>
</html>